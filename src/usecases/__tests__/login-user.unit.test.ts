import { tokenManagerStub } from '__tests__/unit-test-stubs';
import { expect } from 'chai';
import { InvalidToken } from 'utils/errors';
import { LoginUserUsecase } from 'usecases/login-user';

const fakeJWTSecretKey = 'randomeKey2';
const loginUserUsecase = new LoginUserUsecase(
  tokenManagerStub,
  fakeJWTSecretKey
);

const mockAllowedEmails = new Set(['mock@company1.com']);
const validDecodedGooogleToken = {
  email: 'mock@company1.com',
  name: 'John Mock',
  aud: 'client-instance-1',
  emailIsVerified: true,
  iss: 'https://accounts.google.com',
};

describe('LoginUserUsecase', () => {
  afterEach(() => {
    tokenManagerStub.generateToken.reset();
  });
  it('should throw InvalidToken error when user token is invalid', async () => {
    tokenManagerStub.verifySocialLogin.throws(new InvalidToken());
    await expect(
      loginUserUsecase.execute('some_google_token', mockAllowedEmails)
    ).to.be.rejectedWith(InvalidToken);
    tokenManagerStub.verifySocialLogin.calledOnceWith('some_token');
  });

  it('should return the user details and token when the login was successful', async () => {
    const mockToken = 'dummy_token';
    tokenManagerStub.verifySocialLogin.returns(validDecodedGooogleToken);
    tokenManagerStub.generateToken.returns(Promise.resolve(mockToken));

    await expect(
      loginUserUsecase.execute(mockToken, mockAllowedEmails)
    ).to.eventually.eqls({
      user: {
        email: validDecodedGooogleToken.email,
      },
      token: mockToken,
    });

    tokenManagerStub.verifySocialLogin.calledOnceWith(mockToken);
    tokenManagerStub.generateToken.calledOnceWithExactly(fakeJWTSecretKey, {
      email: validDecodedGooogleToken.email,
    });
  });

  it('should throw error when  google has not yet verified the user account', async () => {
    const decodedToken = {
      ...validDecodedGooogleToken,
      emailIsVerified: false,
    };
    tokenManagerStub.verifySocialLogin.returns(decodedToken);

    await expect(
      loginUserUsecase.execute('some_google_token', mockAllowedEmails)
    ).to.be.rejectedWith(InvalidToken);
    tokenManagerStub.verifySocialLogin.calledOnceWith('some_google_token');
  });

  it('should throw an error when the token was not generated by google', async () => {
    const decodedToken = {
      ...validDecodedGooogleToken,
      iss: 'https://nestle.com',
    };
    tokenManagerStub.verifySocialLogin.returns(decodedToken);

    await expect(
      loginUserUsecase.execute('some_google_token', mockAllowedEmails)
    ).to.be.rejectedWith(InvalidToken);
    tokenManagerStub.verifySocialLogin.calledOnceWith('some_google_token');
  });

  it('should throw error when the email is not contained in the email list', async () => {
    const decodedToken = {
      ...validDecodedGooogleToken,
      email: 'unknown@email.com',
    };
    tokenManagerStub.verifySocialLogin.returns(decodedToken);

    await expect(
      loginUserUsecase.execute('some_google_token', mockAllowedEmails)
    ).to.be.rejectedWith(InvalidToken);

    tokenManagerStub.verifySocialLogin.calledOnceWith('some_google_token');
  });
});
